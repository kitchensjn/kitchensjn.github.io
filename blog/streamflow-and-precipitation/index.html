<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>James Kitchens</title>
    <link rel="shortcut icon" type="image/x-icon" href="../../favicon.ico">
    <script src="https://kit.fontawesome.com/b53b88607b.js" crossorigin="anonymous"></script>
    <script src="https://code.jquery.com/jquery-3.5.0.min.js" integrity="sha256-xNzN2a4ltkB44Mc/Jz3pT4iU1cmeR0FkXs4pru/JxaQ=" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
    
    <script>
      function hamburger() {
        var x = document.getElementById("myTopnav");
        if (x.className === "topnav") {
          x.className += " responsive";
          document.getElementById("Logo").classList.add("inactiveLink");
        } else {
          x.className = "topnav";
          document.getElementById("Logo").classList.remove("inactiveLink");
        }
        var content = document.getElementById("galleryContent");
        if (content) {
          if (content.style.top === "62px") {
            content.style.top = ((document.getElementById("myTopnav").querySelectorAll("a").length - 1) * 62 + 3).toString() + "px";
          } else {
            content.style.top = "62px";
          }
        }
      }
      window.addEventListener('resize', function(event){
        var x = document.getElementById("myTopnav");
        var content = document.getElementById("galleryContent");
        if (content) {
          if (window.innerWidth > 768) {
            content.style.top = "53px";
            document.getElementById("Logo").classList.remove("inactiveLink");
          } else if (x.className === "topnav") {
            content.style.top = "53px";
            document.getElementById("Logo").classList.remove("inactiveLink");
          } else {
            content.style.top = ((document.getElementById("myTopnav").querySelectorAll("a").length - 1) * 53 + 3).toString() + "px";
            document.getElementById("Logo").classList.add("inactiveLink");
          }
        };
      });
      
    </script>
    
    <style>
        * {
            margin:0;
            padding:0;
        }
        html, body {
            width: 100%;
            height: 100%;
            position: relative;
        }
        p {
            margin-bottom: 10px;
            font-size: 20px;
            text-align: justify;
        }
        code {
            background-color: #BBBBBB;
            color: #333333;
        }
        .contactBar {
            position: fixed;
            bottom: 0px;
            width: 100%;
            height: 57px;
            background-color: #333333;
            text-align: center;
            color: #BBBBBB;
            z-index: 1000;
        }
        .contactBar .info{
            display: inline-block;
            padding: 17px 20px;
        }
        .cat {
            text-align: left;
        }
        .cat .background {
            display: inline-block;
            border-radius: 5px;
            background-color: #333333;
            margin: 2px 0px;
        }
        .cat .background .skill {
            color: #FFFFFF;
            margin: 5px;
            font-size: 15px;
        }
        
        .topnav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            width: 100%;
            overflow: hidden;
            background-color: #333333;
            z-index: 1000;
            /*font-family: monaco, Consolas, "Lucida Console", monospace;*/
        }
        .menuBurger:link, .menuBurger:visited {
            color: #BBBBBB;
        }
        .menuPage:link {
            color: #BBBBBB;
            text-decoration: none;
        }
        .menuPage:visited {
            color: #BBBBBB;
            text-decoration: none;
        }
        .activePage:link {
            color: #FFFFFF;
            text-decoration: none;
        }
        .menuBurger {
            float: left;
            display: none;
            color: #BBBBBB;
            text-align: center;
            padding: 17px 16px;
            text-decoration: none;
            font-size: 20px;
        }
        .menuBurger:hover {
            color: #FFFFFF;
            text-decoration: none;
        }
        .menuPage {
            float: left;
            display: block;
            color: #BBBBBB;
            text-align: center;
            padding: 17px 16px;
            text-decoration: none;
            font-size: 20px;
        }
        .menuPage:hover {
            color: #FFFFFF;
            text-decoration: none;
        }
        .activePage {
            color: #FFFFFF;
            pointer-events: none;
            cursor: default;
        }
        .activePage:hover {
            text-decoration: none;
        }
        .inactiveLink {
            pointer-events: none;
            cursor: default;
        }
        .inactiveLink:hover {
            text-decoration: none;
        }
        .topnav .icon {
            display: none;
        }
        @media screen and (max-width: 868px) {
            .topnav .menuPage:not(:first-child) {
                display: none;
            }
            .topnav .icon {
                float: right;
                display: block;
            }
            .topnav.responsive {
                position: fixed;
            }
            .topnav.responsive .icon {
                position: fixed;
                right: 0;
                top: 0;
            }
            .topnav.responsive .menuPage {
                float: none;
                display: block;
                text-align: left;
            }
            .topnav.responsive .menuPage:hover {
                background-color: #FFFFFF;
                color: #333333;
            }
            .topnav.responsive {
                border-bottom: 3px solid #333333;
            }
            .contactBar .infoHide {
                display: none;
            }
        }
        
        .postTitle {
          text-align: left;
        }
        .iconLink {
          color: #333333;
        }
        .iconLink:hover {
          color: #BBBBBB;
        }
    </style>
</head>

<body>
    <div class="topnav" id="myTopnav">
      <a class="menuPage" id="Logo" href="../" style="padding:12px 16px 8px 16px;">
        <img src="../JK_logo.png" alt="JK_logo" style="height:38px;">
      </a>
      <a class="menuPage" id="Home" href="../">Home</a>
      <a class="menuPage" id="Bio" href="../#bio">Bio</a>
      <a class="menuPage" id="Projects" href="../#projects">Projects</a>
      <a class="menuPage" id="Blog" href="../#blog">Blog</a>
      <a class="menuPage" id="CV" href="/KitchensJames_CV.pdf" target="_blank">CV</a>
      <a href="javascript:void(0);" class="menuBurger icon" onclick="hamburger()">
        <i class="fa fa-bars"></i>
      </a>
    </div>
    <div style="padding: 75px 10% 75px 10%; text-align: center;">
      <h2 class="postTitle">
        Streamflow and Precipitation
        <a class="iconLink" target="_blank" href="https://github.com/kitchensjn/streamflow-and-precipitation">
          <i class="fab fa-github link" title="GitHub"></i>
        </a>
      </h2>
      <p style="text-align: left;">December 17, 2020</p>
      <div class="cat">
        <div class="background">
            <p class="skill">R</p>
        </div>
        <div class="background">
            <p class="skill">Hydrology</p>
        </div>
        <div class="background">
          <p class="skill">USGS</p>
        </div>
        <div class="background">
          <p class="skill">NOAA</p>
        </div>
      </div>
      <img src="genetic-algorithms/genetic-algorithms.png" width="100%" style="max-width: 600px; border-radius: 5px; margin: 25px 0px;">
      <p>With all of the rain coming to the southeastern United States, I started to think about how it is affecting the river levels. USGS has established streamflow gauges on many of the major rivers across the country; they have also developed an R package (dataRetrieval) that gives simple access to these gauge measurements and more. In this blog post, I’m going to talk about using functions from the dataRetrieval package to access streamflow gauges, delineate river watersheds, and then compare these datasets with other publicly available raster datasets, such as gridded climate datasets from NOAA’s Physical Sciences Laboratory.</p>
      <p>This post requires the following packages to be installed and loaded:</p>
      <p style="text-align: center; margin-top: 25px; margin-bottom: 0;">devtools</p>
      <p style="text-align: center; margin-bottom: 0;">dataRetrieval</p>
      <p style="text-align: center; margin-bottom: 0;">tidyr</p>
      <p style="text-align: center; margin-bottom: 0;">ggplot2</p>
      <p style="text-align: center; margin-bottom: 0;">raster</p>
      <p style="text-align: center; margin-bottom: 25px;">ncdf4</p>
      <p>USGS provides public datasets with numerous applications; the Central Valley Water Resources project during the NASA DEVELOP program greatly utilized these dataset, particularly groundwater field stations measurements from the National Water Inventory System. USGS researchers continue to develop and maintain the dataRetrieval package to aid in accessing these datasets and other tools. The dataRetrieval package can be installed either through CRAN or GitHub. NOTE: There may be version differences depending on the install method. For the rest of this post, we will be using the GitHub version, which, at the writing of this post, had most recently been updated with functions necessary for my analysis.</p>
      <p style="margin-top: 25px; margin-bottom: -1px; text-align: left;"><code style="border-radius: 5px 5px 0px 0px;">console</code></p>
      <pre style="margin-bottom: 25px; padding: 0px 25px; border-radius: 0px 5px 5px 5px;"><code style="display: block; white-space: pre-wrap; text-align: left;">
install.pacakages(“devtools”)
devtools::install_github(“USGS-R/dataRetrieval”)        
      </code></pre>
      <p>You can use the readNWISdv function to access streamflow gauges across the country. You need to know the unique USGS identification number for the gauge you are interested in viewing. The second argument refers to the data that you would like to download; “00060” refers to stream discharge in cubic feet per second (cfs). Lastly, you must provide the start and end dates for the dataset.</p>
      <p style="margin-top: 25px; margin-bottom: -1px; text-align: left;"><code style="border-radius: 5px 5px 0px 0px;">streamflow-and-precipitation.R</code></p>
      <pre style="margin-bottom: 25px; padding: 0px 25px; border-radius: 0px 5px 5px 5px;"><code style="display: block; white-space: pre-wrap; text-align: left;">
gauge <- "02037500"	#Westham Gauge, James River, Richmond, Virginia
streamflow <- dataRetrieval::readNWISdv(gauge, "00060", "2007-01-01", "2020-12-09")
streamflow <- streamflow[,c("Date", "X_00060_00003")]
colnames(streamflow) <- c("Date", "CFS")
streamflow <- streamflow %>% tidyr::complete(Date = seq(min(Date), max(Date), by="days"))            
      </code></pre>
      <p>I’ve stored this dataset as a data.frame named streamflow and changed the names of the columns to Date and CFS to be more understandable. I also filled in any missing measurements dates so that there aren’t any gaps in the record for the study period.</p>
      <p style="margin-top: 25px; margin-bottom: -1px; text-align: left;"><code style="border-radius: 5px 5px 0px 0px;">streamflow-and-precipitation.R</code></p>
      <pre style="margin-bottom: 25px; padding: 0px 25px; border-radius: 0px 5px 5px 5px;"><code style="display: block; white-space: pre-wrap; text-align: left;">
ggplot2::ggplot(data=streamflow) +
  geom_line(aes(Date, CFS))               
      </code></pre>
      <img src="pictures/streamflow.png" width="100%" style="max-width: 600px; border-radius: 5px; margin: 25px 0px;">
      <p>After plotting the streamflow levels, you can see that the James River recently spiked up to 100,000 cfs, 10 years since the previous spike of a similar magnitude. Obviously, there has been a lot of rain within the James River watershed, so let’s figure out exactly how much. To delineate exactly what sections of the land flow towards the gauge coordinates, I’ve returned to the dataRetrieval package.</p>
      <p style="margin-top: 25px; margin-bottom: -1px; text-align: left;"><code style="border-radius: 5px 5px 0px 0px;">streamflow-and-precipitation.R</code></p>
      <pre style="margin-bottom: 25px; padding: 0px 25px; border-radius: 0px 5px 5px 5px;"><code style="display: block; white-space: pre-wrap; text-align: left;">
basin <- dataRetrieval::findNLDI(nwis=gauge, find="basin")$basin              
      </code></pre>
      <p>The findNLDI function was added to the most recent version of the dataRetrieval package on GitHub and at the time of writing this post is not currently available in the CRAN version. This function can delineate a watershed for a given USGS gauge. The basin geometry is stored as a multipolygon within a data.frame or tibble. You can simply view the basin using:</p>
      <p style="margin-top: 25px; margin-bottom: -1px; text-align: left;"><code style="border-radius: 5px 5px 0px 0px;">streamflow-and-precipitation.R</code></p>
      <pre style="margin-bottom: 25px; padding: 0px 25px; border-radius: 0px 5px 5px 5px;"><code style="display: block; white-space: pre-wrap; text-align: left;">
plot(basin)             
      </code></pre>
      <img src="pictures/basin.png" width="100%" style="max-width: 600px; border-radius: 5px; margin: 25px 0px;">
      <p>The James River flows eastward, so the rightmost section is the furthest downstream. There are a number of tributaries that combine with the main flow as the river makes its way out of the Appalachian Mountains.</p>
      <p>If you are interested in delineating watersheds for coordinates not associated with a USGS gauge, I recommend checking out USGS StreamStats tool. It can be accessed as a web application or through R using the streamstats package written by Mark Hagemann. I was originally going to use the streamstats package for this post for some added flexibility, but found that the StreamStats application requires that the gauge coordinates be snapped to the hydrological streamgrid pixels, adding an extra processing step. It’s an informative tool though so I want to be able to implement it in some way.</p>
      <p>Now that we have the basin, we can use its geometry to perform zonal statistics on raster datasets. NOAA provides numerous Gridded Climate datasets through the Physical Sciences Laboratory. <a href="https://psl.noaa.gov/data/gridded/data.unified.daily.conus.rt.html" target="_blank">CPC Unified Gauge-Based Analysis of Daily Precipitation over CONUS RT</a> dataset includes daily precipitation measurements from 2007 to present for the contiguous United States. To be able to follow from here, you will need to download these dataset files, which come in the form of yearly NetCDF files. I’ve stored the files within this directory within my project: “Data/NOAA-PSL/CPC-Unified-Gauge-Based-Analysis-Of-Daily-Precipitation-Over-CONUS-RT/”.</p>
      <p style="margin-top: 25px; margin-bottom: -1px; text-align: left;"><code style="border-radius: 5px 5px 0px 0px;">streamflow-and-precipitation.R</code></p>
      <pre style="margin-bottom: 25px; padding: 0px 25px; border-radius: 0px 5px 5px 5px;"><code style="display: block; white-space: pre-wrap; text-align: left;">
precip_files <- Sys.glob("Data/NOAA-PSL/CPC-Unified-Gauge-Based-Analysis-Of-Daily-Precipitation-Over-CONUS-RT/*")
precip_brick <- raster::brick(lapply(precip_files, FUN=function(x) raster::brick(x)))
precip_brick <- raster::rotate(precip_brick)
precip_basin <- raster::crop(precip_brick, basin)
precip_basin <- raster::mask(precip_basin, basin)                    
      </code></pre>
      <p>This creates a single rasterBrick containing all of the measurements. I used the rotate function to translate the raster from 0:360 degrees to -180:180 degrees longitude. Finally, I used the basin to crop and mask the raster to only include pixels that match the basin. Here’s a plot of the cumulative precipitation during December 12, 2020:</p>
      <p style="margin-top: 25px; margin-bottom: -1px; text-align: left;"><code style="border-radius: 5px 5px 0px 0px;">streamflow-and-precipitation.R</code></p>
      <pre style="margin-bottom: 25px; padding: 0px 25px; border-radius: 0px 5px 5px 5px;"><code style="display: block; white-space: pre-wrap; text-align: left;">
raster::plot(precip_basin$X2020.12.07)                  
      </code></pre>
      <img src="pictures/20201207.png" width="100%" style="max-width: 600px; border-radius: 5px; margin: 25px 0px;">
      <p>To calculate the mean precipitation per day, use the cellStats function:</p>
      <p style="margin-top: 25px; margin-bottom: -1px; text-align: left;"><code style="border-radius: 5px 5px 0px 0px;">streamflow-and-precipitation.R</code></p>
      <pre style="margin-bottom: 25px; padding: 0px 25px; border-radius: 0px 5px 5px 5px;"><code style="display: block; white-space: pre-wrap; text-align: left;">
streamflow$Precip <- cellStats(precip_basin, stat="mean")
ggplot(streamflow) +
  geom_line(aes(Date, Precip))                         
      </code></pre>
      <img src="pictures/precipitation.png" width="100%" style="max-width: 600px; border-radius: 5px; margin: 25px 0px;">
      <p>To measure the correlation between the mean precipitation in the basin and the streamflow gauge measurement, we can calculate the Pearson correlation using the cor.test function:</p>
      <p style="margin-top: 25px; margin-bottom: -1px; text-align: left;"><code style="border-radius: 5px 5px 0px 0px;">streamflow-and-precipitation.R</code></p>
      <pre style="margin-bottom: 25px; padding: 0px 25px; border-radius: 0px 5px 5px 5px;"><code style="display: block; white-space: pre-wrap; text-align: left;">
cor.test(streamflow$CFS, streamflow$Precip, method="pearson")                         
      </code></pre>
      <p>The correlation value between the two datasets was 0.108, which is a weak correlation, but this should be expected as there are many contributing factors that we did not include, such as seasonality, previous recent rain events, and the fact that precipitation further upstream may not affect gauge levels in the same pattern as precipitation right at the gauge location.</p>
      <p>To test the latter reasoning, I wanted to look at how each pixel of the raster individually correlated with the gauge measurements over time. I did not find a standard function to do this; the closest I found was Abdulhakim Abdi’s gridcorts function comparing measuring the pixelwise correlation between two rasterBrick, which would have worked but required that the streamflow gauge measurements be converted into a rasterBrick. Since this was a relatively simple task, I wrote two functions that work in tandem:</p>
      <p style="margin-top: 25px; margin-bottom: -1px; text-align: left;"><code style="border-radius: 5px 5px 0px 0px;">streamflow-and-precipitation.R</code></p>
      <pre style="margin-bottom: 25px; padding: 0px 25px; border-radius: 0px 5px 5px 5px;"><code style="display: block; white-space: pre-wrap; text-align: left;">
pixelwiseCorrelation <- function(brick, timeseries, method) {
  correlation <- calc(brick, fun=function(x){correlation.test(x, timeseries=timeseries, method=method, value="correlation")})
  p.value <- calc(brick, fun=function(x){correlation.test(x, timeseries=timeseries, method=method, value="p-value")})
  stats <- brick(correlation, p.value)
  names(stats) <- c("correlation", "p.value")
  return(stats)
}

correlation.test <- function(x, timeseries, method, value) {
  if (all(is.na(x))) {
    return(NA)
  } else {
    if (value=="correlation") {
      return(cor.test(x, timeseries, method=method)$estimate) 
    } else if (value == "p-value") {
      return(cor.test(x, timeseries, method=method)$p.value)
    }
  }
}                                 
      </code></pre>
      <p>pixelwiseCorrelation takes in a rasterBrick, a vector of measurement values, and a correlation method name. Within this function, the calc function performs pixelwise calculations; normally, this function cannot take additional arguments, but by having the called function call another function, we can get around this issue. The first time calc is called, correlation.test returns the correlation estimate because I passed “correlation” into the value parameter; the second time it returns the p-value. These are then combined into a rasterBrick and returned together. With those functions added, we can run the pixelwiseCorrelation and plot the results to see which pixels are most highly correlated.</p>
      <p style="margin-top: 25px; margin-bottom: -1px; text-align: left;"><code style="border-radius: 5px 5px 0px 0px;">streamflow-and-precipitation.R</code></p>
      <pre style="margin-bottom: 25px; padding: 0px 25px; border-radius: 0px 5px 5px 5px;"><code style="display: block; white-space: pre-wrap; text-align: left;">
pearson <- pixelwiseCorrelation(brick=precip_basin, timeseries=streamflow$CFS, method="pearson")
raster::plot(pearson)                                        
      </code></pre>
      <img src="pictures/correlation.png" width="100%" style="max-width: 600px; border-radius: 5px; margin: 25px 0px;">
      <p style="text-align: center; margin-top: -75px;">Correlation</p>
      <img src="pictures/p.value.png" width="100%" style="max-width: 600px; border-radius: 5px; margin: 25px 0px;">
      <p style="text-align: center; margin-top: -75px; margin-bottom: 50px;">P-value</p>
      <p>For this example of the James River, we can see that pixels that are further downstream and therefore closer to the streamflow gauge have higher levels of correlation between precipitation and streamflow. The maximum correlation is 0.139 and minimum is 0.060. As we are comparing measurements on a given day, we aren’t accounting for the time that it takes the water to reach the gauge when raining far upstream. Because of this, rain much closer to the gauge is more directly affecting levels measured.</p>
      <p>All of the code used in this post can be found <a href="https://github.com/kitchensjn/streamflow-and-precipitation" target="_blank">HERE</a>. If you enjoyed this tutorial and want to use this code in your own project, give the repository a star on GitHub and fork the project to your own profile. If you have any questions, create an Issue for the GitHub repository and I will do my best to help!</p>
    </div>
    <div id="contact" class="contactBar">
        <p class="info infoHide">Pomona, California</p>
        <p class="info infoHide">|</p>
        <p class="info">kitchensjn@gmail.com</p>
        <p class="info infoHide">|</p>
        <p class="info infoHide">(804) 572-3197</p>
    </div>
</body>

</html>