I"õz<p class="images"><img src="/assets/blog/national-parks-gallery/photos/GRBA/20200906_meg_0146.jpg" alt="Great Basin - Stella Lake" /></p>

<p>A few years ago, I found a saw a Reddit user post a graphic of statistics from their thru-hike of the Pacific Crest Trail, including information on daily mileage and cost of the trip as a whole (<a href="https://www.reddit.com/r/PacificCrestTrail/comments/dzlppa/my_brother_tracked_his_stats_from_his_thru_hike/">original post</a>). I really like this design and thought that I would build on it.</p>

<h3 id="daily-mileage">Daily Mileage</h3>

<p>I didn‚Äôt collect many stats during my thru-hike of the Appalachian Trail (AT) in 2016, and in some cases I preferred to be a bit ignorant of measurements like how much my pack weighed (It was really heavy, I could tell that by just picking it up. I didn‚Äôt need a number). Thankfully, family members recorded my approximate camping location nearly every night by cross-referencing my GPS locater position to waypoints found in Thru-Hiker‚Äôs Companion, the official guidebook published by the Appalachian Trail Conservancy.</p>

<p>I went through every entry by hand and noted the mileage of each campsite. I had to correct a few which didn‚Äôt align with where I remembered camping, but for the most part the locations were very accurate. I used this to generate a daily mileage measurements for the hike.</p>

<h3 id="elevation">Elevation</h3>

<p>I thought that an elevation profile of the trail in each state would be interesting to add to the data visualization. When looking for resources online, I came across <a href="https://www.postholer.com">Postholer.com</a>, which is an online resource for trail waypoints. It includes mileage and elevation of many of these points, so I set up a web scraper to aggregate these data into a single file on my computer.</p>

<p class="codeheader">postholer-scraper.py</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>


<span class="k">def</span> <span class="nf">table_to_array</span><span class="p">(</span><span class="n">table</span><span class="p">):</span>
    <span class="n">array</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">table</span><span class="p">.</span><span class="n">findAll</span><span class="p">(</span><span class="s">'tr'</span><span class="p">):</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">row</span><span class="p">.</span><span class="n">findAll</span><span class="p">(</span><span class="s">'td'</span><span class="p">)</span>
        <span class="n">output_row</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">output_row</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">column</span><span class="p">.</span><span class="n">text</span><span class="p">)</span>
        <span class="n">array</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_row</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">array</span>

<span class="k">def</span> <span class="nf">rescale</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">start1</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">start2</span><span class="p">,</span> <span class="n">end2</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">value</span><span class="o">-</span><span class="n">start1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">end1</span><span class="o">-</span><span class="n">start1</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">end2</span><span class="o">-</span><span class="n">start2</span><span class="p">)</span><span class="o">+</span><span class="n">start2</span>


<span class="c1"># Postholer has broken the AT into segments defined by starting mileage
# These starting mileages are used for the URLs 
</span><span class="n">sections</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">53.3</span><span class="p">,</span> <span class="mf">166.4</span><span class="p">,</span> <span class="mf">276.5</span><span class="p">,</span> <span class="mf">393.9</span><span class="p">,</span> <span class="mf">467.6</span><span class="p">,</span> <span class="mf">587.9</span><span class="p">,</span> <span class="mf">703.1</span><span class="p">,</span> <span class="mf">784.7</span><span class="p">,</span> <span class="mf">862.0</span><span class="p">,</span> <span class="mf">979.9</span><span class="p">,</span> <span class="mf">1026.1</span><span class="p">,</span> <span class="mf">1124.5</span><span class="p">,</span> <span class="mf">1223.5</span><span class="p">,</span> <span class="mf">1299.5</span><span class="p">,</span> <span class="mf">1408.3</span><span class="p">,</span> <span class="mf">1503.2</span><span class="p">,</span> <span class="mf">1613.4</span><span class="p">,</span> <span class="mf">1706.1</span><span class="p">,</span> <span class="mf">1750.1</span><span class="p">,</span> <span class="mf">1856.9</span><span class="p">,</span> <span class="mf">1963.8</span><span class="p">,</span> <span class="mf">2064.6</span><span class="p">]</span>

<span class="c1"># Loops through the sections and scrapes waypoints table
# Aggregates to all_data array
</span><span class="n">all_data</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">header</span> <span class="o">=</span> <span class="bp">True</span>
<span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="n">sections</span><span class="p">:</span>
    <span class="n">section_data</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">requests</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"https://www.postholer.com/databook/Appalachian-Trail/3/"</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sec</span><span class="p">)).</span><span class="n">text</span><span class="p">,</span> <span class="s">"html.parser"</span><span class="p">)</span>
    <span class="n">waypoints</span> <span class="o">=</span> <span class="n">section_data</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"table"</span><span class="p">,</span> <span class="p">{</span><span class="s">"class"</span><span class="p">:</span> <span class="s">"wptTable"</span><span class="p">})</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">table_to_array</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">waypoints</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">header</span><span class="p">:</span>
        <span class="n">all_data</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">header</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">:]:</span>
        <span class="n">all_data</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>


<span class="c1"># Save select waypoint's description, mile, and elevation to CSV
# Removes waypoints without mileage and elevation data
</span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'AT-waypoints.csv'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
    <span class="n">number_of_rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_data</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_rows</span><span class="p">):</span>
        <span class="n">row_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_data</span><span class="p">[</span><span class="n">row</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">all_data</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s">""</span> <span class="ow">and</span> <span class="n">all_data</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s">""</span> <span class="ow">and</span> <span class="n">all_data</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">!=</span> <span class="s">""</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">]:</span>
                <span class="n">outfile</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">all_data</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">column</span><span class="p">]</span> <span class="o">+</span> <span class="s">","</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">outfile</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s">"Rescaled,Highlight"</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">outfile</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">rescale</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">all_data</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="n">start1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end1</span><span class="o">=</span><span class="mf">2180.0</span><span class="p">,</span> <span class="n">start2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end2</span><span class="o">=</span><span class="mf">2189.1</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="s">","</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">row</span> <span class="o">!=</span> <span class="n">number_of_rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">outfile</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>

</code></pre></div></div>

<p>Because Postholer separates the trail into many sections, I looped through each section and appended the data to an array which was then written to a csv. I used the BeautifulSoup module to extract the mileage table from the website. Over the years, the trail has changed, being extended in certain states. Because of this the mileage in my guidebook did not perfectly align with that on Postholer. In 2016, the Appalachian Trail was officially measured to be 2189.1 miles in length. Postholer instead says that the trail is 2180 miles (measurement date unknown). With the goal of combining these two datasets, I needed to make sense of these different measurements. My imperfect solution was to rescale the Postholer range to match the official 2016 mileage. As this isn‚Äôt leading to rigorous study and publication, I thought it‚Äôll work well enough. I also added a ‚ÄúHighlight‚Äù column for future work thinking that I may want to highlight certain waypoints on the charts, such as where I camped each night or mountain names.</p>

<p>Here is the plots of the trail elevation profile made in D3.js:</p>

<script src="https://d3js.org/d3.v4.js"></script>

<div style="text-align: center; margin: 0px 10px;">
<div style="text-align: center; ">
    <select id="stateSelect"></select>
    <div id="elevationPlot" style="margin: 0px;"></div>
</div>
<script>
    d3.csv("/assets/blog/thru-hiking-data-viz/AT-states.csv",
        function(data) {
            // add the options to the button
            d3.select("#stateSelect")
            .selectAll('myOptions')
            .data(data)
            .enter()
            .append('option')
            .text(function (d) { return d.State; }) // text showed in the menu
            .attr("value", function (d) { return [d.Start, d.End]; }) // corresponding value returned by the button
        }
    )
    // set the dimensions and margins of the graph
    var margin = {top: 20, right: 20, bottom: 40, left: 60},
        width = 600 - margin.left - margin.right,
        height = 400 - margin.top - margin.bottom;
    // append the svg object to the body of the page
    var svg = d3.select("#elevationPlot")
        .append("svg")
        .style("max-width", "600")
        .attr("viewBox", "0 0 600 400")
        .attr("perserveAspectRatio", "xMinYMid")
        .append("g")
        .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")");
    svg.append("text")             
      .attr("transform",
            "translate(" + (width/2) + " ," + 
                           (height + margin.top + 20) + ")")
      .style("text-anchor", "middle")
      .text("Mile");
    svg.append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 0 - margin.left)
      .attr("x",0 - (height / 2))
      .attr("dy", "1em")
      .style("text-anchor", "middle")
      .text("Elevation (ft)");
    //Read the data
    d3.csv("/assets/blog/thru-hiking-data-viz/AT-waypoints.csv",
        // Now I can use this dataset:
        function(data) {
            highlight = data.filter(function(d) {
                return d.Highlight != "";
            })
            // Add X axis --> it is a date format
            var x = d3.scaleLinear()
                .domain([d3.min(data, function(d) { return +d.Rescaled; }), d3.max(data, function(d) { return +d.Rescaled; })])
                //.domain([0, d3.max(data, function(d) { return +d.Rescaled; })])
                .range([ 0, width ]);
            var x_axis = svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x));
            // Add Y axis
            var y = d3.scaleLinear()
                .domain([0, 6607])
                .range([ height, 0 ]);
            svg.append("g")
                .call(d3.axisLeft(y));
            // Add the line
            var elevation = svg.append("path")
                .datum(data)
                .attr("fill", "#337ab7")
                .attr("stroke", "#337ab7")
                .attr("stroke-width", 0)
                .attr("d", d3.area()
                    //.curve(d3.curveMonotoneX)
                    .x(function(d) { return x(d.Rescaled) })
                    .y0(y(0))
                    .y1(function(d) { return y(d.Elev) })
                );
            function update(range) {
                range = range.split(",")
                state_elevation = data.filter(function(d) {
                    return +d.Rescaled >= +range[0] && d.Rescaled <= +range[1];
                })
                highlight = state_elevation.filter(function(d) {
                    return d.Highlight != "";
                })
                // Add X axis --> it is a date format
                var x = d3.scaleLinear()
                    .domain([d3.min(state_elevation, function(d) { return +d.Rescaled; }), d3.max(state_elevation, function(d) { return +d.Rescaled; })])
                    //.domain([0, d3.max(data, function(d) { return +d.Rescaled; })])
                    .range([ 0, width ]);
                x_axis
                    .attr("transform", "translate(0," + height + ")")
                    .call(d3.axisBottom(x));
                elevation
                    .datum(state_elevation)
                    .attr("d", d3.area()
                        //.curve(d3.curveMonotoneX)
                        .x(function(d) { return x(d.Rescaled) })
                        .y0(y(0))
                        .y1(function(d) { return y(d.Elev) })
                    )
            }
            // When the button is changed, run the updateChart function
            d3.select("#stateSelect").on("change", function(d) {
                // recover the option that has been chosen
                var range = d3.select(this).property("value");
                // run the updateChart function with this selected option
                update(range);
            })
        }
    )
</script>


{:.codeheader}
elevation-D3.html
```html
<script src="https://d3js.org/d3.v4.js"></script>

<div style="text-align: center; margin: 0px 10px;">
    <select id="stateSelect"></select>
    <div id="elevationPlot"></div>
</div>

<script>

    d3.csv("/assets/blog/thru-hiking-data-viz/AT-states.csv",
        function(data) {
            // add the options to the button
            d3.select("#stateSelect")
            .selectAll('myOptions')
            .data(data)
            .enter()
            .append('option')
            .text(function (d) { return d.State; }) // text showed in the menu
            .attr("value", function (d) { return [d.Start, d.End]; }) // corresponding value returned by the button
        }
    )

    // set the dimensions and margins of the graph
    var margin = {top: 20, right: 20, bottom: 40, left: 60},
        width = 600 - margin.left - margin.right,
        height = 400 - margin.top - margin.bottom;

    // append the svg object to the body of the page
    var svg = d3.select("#elevationPlot")
        .append("svg")
        .style("max-width", "600")
        .attr("viewBox", "0 0 600 400")
        .attr("perserveAspectRatio", "xMinYMid")
        .append("g")
        .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")");

    svg.append("text")             
      .attr("transform",
            "translate(" + (width/2) + " ," + 
                           (height + margin.top + 20) + ")")
      .style("text-anchor", "middle")
      .text("Mile");

    svg.append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 0 - margin.left)
      .attr("x",0 - (height / 2))
      .attr("dy", "1em")
      .style("text-anchor", "middle")
      .text("Elevation (ft)");

    //Read the data
    d3.csv("/assets/blog/thru-hiking-data-viz/AT-waypoints.csv",
        
        // Now I can use this dataset:
        function(data) {
            highlight = data.filter(function(d) {
                return d.Highlight != "";
            })
            // Add X axis --> it is a date format
            var x = d3.scaleLinear()
                .domain([d3.min(data, function(d) { return +d.Rescaled; }), d3.max(data, function(d) { return +d.Rescaled; })])
                //.domain([0, d3.max(data, function(d) { return +d.Rescaled; })])
                .range([ 0, width ]);

            var x_axis = svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x));

            // Add Y axis
            var y = d3.scaleLinear()
                .domain([0, 6607])
                .range([ height, 0 ]);

            svg.append("g")
                .call(d3.axisLeft(y));

            // Add the line
            var elevation = svg.append("path")
                .datum(data)
                .attr("fill", "#337ab7")
                .attr("stroke", "#337ab7")
                .attr("stroke-width", 0)
                .attr("d", d3.area()
                    //.curve(d3.curveMonotoneX)
                    .x(function(d) { return x(d.Rescaled) })
                    .y0(y(0))
                    .y1(function(d) { return y(d.Elev) })
                );

            function update(range) {
                range = range.split(",")
                state_elevation = data.filter(function(d) {
                    return +d.Rescaled >= +range[0] && d.Rescaled <= +range[1];
                })
                highlight = state_elevation.filter(function(d) {
                    return d.Highlight != "";
                })
                // Add X axis --> it is a date format
                var x = d3.scaleLinear()
                    .domain([d3.min(state_elevation, function(d) { return +d.Rescaled; }), d3.max(state_elevation, function(d) { return +d.Rescaled; })])
                    //.domain([0, d3.max(data, function(d) { return +d.Rescaled; })])
                    .range([ 0, width ]);
                x_axis
                    .attr("transform", "translate(0," + height + ")")
                    .call(d3.axisBottom(x));
                elevation
                    .datum(state_elevation)
                    .attr("d", d3.area()
                        //.curve(d3.curveMonotoneX)
                        .x(function(d) { return x(d.Rescaled) })
                        .y0(y(0))
                        .y1(function(d) { return y(d.Elev) })
                    )
            }

            // When the dropdown is changed, run the updateChart function
            d3.select("#stateSelect").on("change", function(d) {
                // recover the option that has been chosen
                var range = d3.select(this).property("value");
                // run the updateChart function with this selected option
                update(range);
            })

        }

    )
</script>
```

It took me a little while to figure out how to make the charts responsive. There seems to be a few solutions, but the most elegant that I found attaches the "viewBox" and "perserveAspectRatio" attributes to the svg element.

{:.codeheader}
D3.js Snippet
```javascript
.attr("viewBox", "0 0 600 400")
.attr("perserveAspectRatio", "xMinYMid")
```

The elevations profiles are decent, but there seems to be a number of errors within the Postholer data that lead to sharp peaks and inconsistent gaps between waypoints. Because of this, I wanted to look into other options for accessing trail elevation data. I found a GPX file for the entire trail ([here](http://topofusion.com/at-gps.php), the full resolution version) and extracted the position and elevation data into a csv using a modified version of the Python script found in this blog post, [How tracking apps analyse your GPS data: a hands-on tutorial in Python](https://towardsdatascience.com/how-tracking-apps-analyse-your-gps-data-a-hands-on-tutorial-in-python-756d4db6715d).

{:.codeheader}
gpx-to-csv.py
```python
import gpxpy
from geopy import distance
import math
import numpy as np
import pandas as pd
import haversine
import matplotlib.pyplot as plt


def rescale(value, start1, end1, start2, end2):
    return ((value-start1)/(end1-start1))*(end2-start2)+start2


gpx_file = open("AT-track.gpx")
gpx = gpxpy.parse(gpx_file)
data = gpx.tracks[0].segments[0].points

# Build a pandas.DataFrame from the GPX
df = pd.DataFrame(columns=['lon', 'lat', 'elev'])
for point in data:
    df = df.append({'lon': point.longitude, 'lat' : point.latitude, 'elev' : point.elevation}, ignore_index=True)

# Calculate 3D distances using Haversine formula
# Convert from meters to miles
dist = []
for index in range(df.shape[0]):
    if index == 0:
        dist.append(0)
    else:
        dist_2d = haversine.haversine((df["lat"][index-1], df["lon"][index-1]), (df["lat"][index], df["lon"][index])) * 1000
        elev_change = df["elev"][index-1] - df["elev"][index]
        dist_3d = math.sqrt(dist_2d**2 + elev_change**2)
        dist.append(dist[index-1] + dist_3d / 1609)
df["dist"] = dist

# Rescale measured distance so that it matches the expected distance from guidebook
df["rescaled_dist"] = rescale(value=df["dist"], start1=min(df["dist"]), end1=max(df["dist"]), start2=0.0, end2=2189.1)
df["elev_feet"] = df["elev"] * 3.281    # Convert from meters to feet

df.to_csv("AT-track.csv", index=False)
```

This code extracts the GPX data into a pandas.DataFrame, then calculates the three-dimensional Haversine distances between the points along the trail using latitude, longitude, and elevation. Interestingly, the GPX file had the calculated trail length at 2138.7 miles, once again compared to the 2189.1 miles shown in the guidebook. To account for this, I once again rescaled the mileage to match the expected length. The new trail elevation plots look very similar to the original one's that used Postholer data, but with a more uniform and dense distribution of waypoints. The code is also nearly identical, so I won't redisplay it here.

<div style="text-align: center;">
    <select id="stateSelect2"></select>
    <div id="elevationPlot2"></div>
</div>
<script>
    d3.csv("/assets/blog/thru-hiking-data-viz/AT-states.csv",
        function(data) {
            // add the options to the button
            d3.select("#stateSelect2")
            .selectAll('myOptions')
            .data(data)
            .enter()
            .append('option')
            .text(function (d) { return d.State; }) // text showed in the menu
            .attr("value", function (d) { return [d.Start, d.End]; }) // corresponding value returned by the button
        }
    )
    // set the dimensions and margins of the graph
    var margin = {top: 20, right: 20, bottom: 40, left: 60},
        width = 600 - margin.left - margin.right,
        height = 400 - margin.top - margin.bottom;
    // append the svg object to the body of the page
    var svg2 = d3.select("#elevationPlot2")
        .append("svg")
        .style("max-width", "600")
        .attr("viewBox", "0 0 600 400")
        .attr("perserveAspectRatio", "xMinYMid")
        .append("g")
        .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")");
    svg2.append("text")             
      .attr("transform",
            "translate(" + (width/2) + " ," + 
                           (height + margin.top + 20) + ")")
      .style("text-anchor", "middle")
      .text("Mile");
    svg2.append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 0 - margin.left)
      .attr("x",0 - (height / 2))
      .attr("dy", "1em")
      .style("text-anchor", "middle")
      .text("Elevation (ft)");
    //Read the data
    d3.csv("/assets/blog/thru-hiking-data-viz/AT-track.csv",
        // Now I can use this dataset:
        function(data) {
            highlight = data.filter(function(d) {
                return d.Highlight != "";
            })
            // Add X axis --> it is a date format
            var x = d3.scaleLinear()
                .domain([d3.min(data, function(d) { return +d.rescaled_dist; }), d3.max(data, function(d) { return +d.rescaled_dist; })])
                //.domain([0, d3.max(data, function(d) { return +d.Rescaled; })])
                .range([ 0, width ]);
            var x_axis = svg2.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x));
            // Add Y axis
            var y = d3.scaleLinear()
                .domain([0, d3.max(data, function(d) { return +d.elev_feet; })])
                .range([ height, 0 ]);
            svg2.append("g")
                .call(d3.axisLeft(y));
            // Add the line
            var elevation = svg2.append("path")
                .datum(data)
                .attr("fill", "#337ab7")
                .attr("stroke", "#337ab7")
                .attr("stroke-width", 0)
                .attr("d", d3.area()
                    //.curve(d3.curveMonotoneX)
                    .x(function(d) { return x(d.rescaled_dist) })
                    .y0(y(0))
                    .y1(function(d) { return y(d.elev_feet) })
                )
            function update(range) {
                range = range.split(",")
                state_elevation = data.filter(function(d) {
                    return +d.rescaled_dist >= +range[0] && d.rescaled_dist <= +range[1];
                })
                highlight = state_elevation.filter(function(d) {
                    return d.Highlight != "";
                })
                // Add X axis --> it is a date format
                var x = d3.scaleLinear()
                    .domain([d3.min(state_elevation, function(d) { return +d.rescaled_dist; }), d3.max(state_elevation, function(d) { return +d.rescaled_dist; })])
                    //.domain([0, d3.max(data, function(d) { return +d.Rescaled; })])
                    .range([ 0, width ]);
                x_axis
                    .attr("transform", "translate(0," + height + ")")
                    .call(d3.axisBottom(x));
                elevation
                    .datum(state_elevation)
                    .attr("d", d3.area()
                    //.curve(d3.curveMonotoneX)
                    .x(function(d) { return x(d.rescaled_dist) })
                    .y0(y(0))
                    .y1(function(d) { return y(d.elev_feet) })
                    )
            }
            // When the button is changed, run the updateChart function
            d3.select("#stateSelect2").on("change", function(d) {
                // recover the option that has been chosen
                var range = d3.select(this).property("value");
                // run the updateChart function with this selected option
                update(range);
            })
        }
    )
</script>

Because the starting trail length and rescaled trail length were pretty significantly different.
</div>
:ET